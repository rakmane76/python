'''
VS2008 C++03 code when migrated to VS 2019 Modern C++ 20 std. Compilation fails with repetitive errors and warnings. 
Attempt to  automate resolving the errors. Python script will update the code and recompiling it should resolve the errors. 
For it, first compile the code in VS 2019 and store the error output generated by build in txt file. 
Call python script and pass txt file as parameter. 
General Errors/Warning solved are 2440 and 2664.
'''
import sys
import os
import re
import fileinput
from collections import defaultdict

error_dict = defaultdict(str)
warn_dict = defaultdict(str)

def getFile(line) :
    gr = re.search(r"^\d+>(.*)\(\d", line)
    file = gr.group(1)
    if (not os.path.isfile(file)) or (not os.access(file, os.R_OK|os.W_OK)) :
        errorStr="Cannot open or edit file :" + file
        raise Exception(errorStr)
    return file

def getLineCol(line) :
    gr = ""
    if line.find('error C') != -1 :
        gr = re.search(r"^.*\((.*)\):.* to (.*)$", line)
    elif line.find('message :') != -1 :
        gr = re.search(r"^.*\((.*)\):.* message (.*)$", line)
    else :
        gr = re.search(r"^.*\((.*)\):.* warning (.*)$", line)

    line_no = int(gr.group(1).split(',')[0])
    col_no = int(gr.group(1).split(',')[1])
    return gr, line_no, col_no


def parseErr_2440(lines, input_line) :
    gr, line_no, col_no = getLineCol(lines[0])
    convert_to = gr.group(2).replace("'","")
    gr, line_2, col_2 = getLineCol(lines[1])
    
    out_string = ""
    if (convert_to.find('&') != -1) :
        if (lines[1].find('reference') != -1) :
            out_string = input_line.replace('&', '')
        else :
            out_string = input_line 
    elif (input_line.find('=') != -1) :
        if input_line[col_2-1] == '=' :
            col_2 = col_2 + 1
        out_string=input_line[:col_2-1] + "(" + convert_to + ")("
        out_string += input_line[col_2-1:col_no-1] + ")" + input_line[col_no-1:]
    elif (col_no == col_2) : 
        out_string=input_line[:col_2-1] + "(" + convert_to + ")("
        if input_line.find(',',col_2) != -1 : 
            last_pos = input_line.find(',',col_2)
            out_string += input_line[col_2-1:last_pos] + ")" + input_line[last_pos:]
        elif input_line.find(')',col_2) != -1 : 
            last_pos = input_line.find(')',col_2)
            out_string += input_line[col_2-1:last_pos] + ")" + input_line[last_pos:]
    else :
        out_string=input_line[:col_no-1] + "(" + convert_to + ")("
        col_2 = input_line.find('"', col_no+1)
        out_string += input_line[col_no-1:col_2+1] + ")" + input_line[col_2+1:]

    return out_string


def parseErr_2664(lines, input_line) : 
    gr, line_no, col_no = getLineCol(lines[0])
    convert_to = gr.group(2).replace("'","")
    gr, line_2, col_2 = getLineCol(lines[1])
    out_string=""
    if line_no == line_2 :
        out_string=input_line[:col_2-1] + "(" + convert_to + ")("
        if input_line[col_2-1] == '"' :
            col_no = input_line.find('"',col_2)
            col_no = col_no + 1
        out_string += input_line[col_2-1:col_no] + ")" + input_line[col_no:]
    else  : 
        out_string=input_line[:col_2-1] + "(" + convert_to + ")("
        if input_line.find(',',col_2) != -1 : 
            last_pos = input_line.find(',',col_2)
            out_string += input_line[col_2-1:last_pos] + ")" + input_line[last_pos:]
        elif input_line.find(')',col_2) != -1 : 
            last_pos = input_line.find(')',col_2)
            out_string += input_line[col_2-1:last_pos] + ")" + input_line[last_pos:]

    return out_string


def processErrors(file, errors) : 
    lines = errors[0]
    line_no = getLineCol(lines[0])[1]
    errors.pop(0)
    
    i=1
    with fileinput.FileInput(file, inplace = True, backup ='.bkup') as infile :
        for input_line in infile :
            if i == line_no :
                if (lines[0].find('C2440') != -1) : 
                    second_line_no = getLineCol(lines[1])[1]
                    while i < second_line_no :
                        print(input_line, end='')
                        input_line = infile.readline()
                        i = i+1
                    out_string = parseErr_2440(lines, input_line)
                elif (lines[0].find('C2664') != -1) :
                    second_line_no = getLineCol(lines[1])[1]
                    while i < second_line_no :
                        print(input_line, end='')
                        input_line = infile.readline()
                        i = i+1
                    out_string = parseErr_2664(lines, input_line)
                print(out_string, end='')
                if errors :
                    lines = errors[0]
                    line_no = getLineCol(lines[0])[1]
                    errors.pop(0)
                else :
                    line_no = 0
            else :
                print(input_line, end='')
            i = i+1

def processWarn(file, warnings) : 
    warn = warnings[0]
    line_no = getLineCol(warn)[1]
    warnings.pop(0)

    i=1
    with fileinput.FileInput(file, inplace = True, backup ='.bkup') as infile :
        for input_line in infile :
            if i == line_no :
                if (warn.find('treating as noexcept(false)') != -1) :
                    out_string = ""
                    if (input_line.find('throw')) != -1 :
                        out_string = re.sub(r"_*throw", "noexcept(false)", input_line)
                    else :
                        print(input_line, end='')
                        input_line = infile.readline()
                        i = i+1
                        if (input_line.find('throw')) != -1 :
                            out_string = re.sub(r"_*throw", "noexcept(false)", input_line)
                        else : 
                            print(input_line, end='')
                    print(out_string, end='')
                if warnings : 
                    warn = warnings[0]
                    line_no = getLineCol(warn)[1]
                    warnings.pop(0)
                else :
                    line_no = 0
            else :
                print(input_line, end='')
            i = i+1

    

num_args = len(sys.argv)

if num_args < 2 :
    raise Exception('Pass build error file as parameter to list') 

build_error_file = sys.argv[1]

if (not os.path.isfile(build_error_file)) or (not os.access(build_error_file, os.R_OK)) :
    errorStr="Opening File : " + build_error_file + " , error"
    raise Exception(errorStr)

with open(build_error_file) as build_file : 
    line = build_file.readline()
    while line :
        line = build_file.readline()
        if ((line.find('C2440') != -1) or (line.find('C2664') != -1)) :
            file = getFile(line)
            listLine = [line]
            listLine.append(build_file.readline())
            if file in error_dict : 
                error_dict[file].append(listLine)
            else : 
                error_dict[file] = [listLine]
        elif (line.find('C5040') != -1) :
            file = getFile(line)
            new_line = re.sub(r"^.*[0-9]>", "", line)
            if file not in warn_dict : 
                warn_dict[file] = [new_line]
            else : 
                warn_dict[file].append(new_line)
 
# order warning correctly 
warn_dict1 = defaultdict(str)
for key, val in warn_dict.items() : 
    warn_messages = list(dict.fromkeys(val))
    warn_dict1[key] = warn_messages


print("Finished parsing build error file, Starting Processing errors")
for key, val in error_dict.items() : 
    print("Processing: {}, issues:{}".format(key, len(val)))
    processErrors(key, val)

for key, val in warn_dict1.items() : 
    print("Processing: {}, issues:{}".format(key, len(val)))
    processWarn(key, val)

